#!/usr/bin/python3
from __future__ import print_function
import sys
import os
import os.path as path
import glob2
import concurrent.futures
import multiprocessing
import subprocess

extensions = ['mp3', 'm4a', 'wav', 'aac', 'flac', 'wma']

if len(sys.argv) < 2 or '--help' in sys.argv[1]:
	print('usage: %s [dir] [outputdir]'%sys.argv[0])
	print('converts all audio files in a directory to mp3/128kb')
	print('supported extensions:', str.join(', ', extensions))
	print('creates new directory [dir]_128 if [outputdir] is not specified')

inputdir = path.abspath(sys.argv[1])
outputdir = inputdir + '_128'

if len(sys.argv) > 2:
	outputdir = path.abspath(sys.argv[2])

print('input directory:', inputdir)
print('output directory:', outputdir)

inputfiles = []

for ext in extensions:
	inputfiles.extend(glob2.glob(inputdir + '/*.' + ext))
	inputfiles.extend(glob2.glob(inputdir + '/**/*.' + ext))

inputfiles = [path.relpath(filepath, inputdir) for filepath in inputfiles]

print(f'found {len(inputfiles)} files')

def convert(f, run=3):
	fin = inputdir + '/' + f
	fout = outputdir + '/' + os.path.splitext(f)[0] + '.mp3'

	if run == 0:
		print('too many retries:', f)
		return

	if path.isfile(fout) and run != 3:
		print('file exists:', f)
		return

	print('run', run, 'converting', f)


#	os.remove(fout) if path.isfile(fout) else None


	if not path.isdir(path.dirname(fout)):
		os.makedirs(path.dirname(fout))

	command = [
		'ffmpeg',
		'-i', fin,
		'-map', '0',
		'-c:v', 'copy',
		'-c:a', 'libmp3lame',
		'-q:a', '5',
		'-y',
		'-loglevel', 'quiet',
		fout
	]

	retcode = subprocess.call(command)

	if retcode:
		print('ffmpeg returned ', retcode, 'for', f)
		convert(f, run - 1)


with concurrent.futures.ThreadPoolExecutor(max_workers=multiprocessing.cpu_count()) as executor:
	for f in inputfiles:
		executor.submit(convert, f)

	executor.shutdown(wait=True)

print('done')
os.system('stty echo')
