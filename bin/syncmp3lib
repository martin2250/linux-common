#!/usr/bin/python
from __future__ import print_function

import argparse
import concurrent.futures
import datetime
import multiprocessing
import os
import os.path as path
import subprocess
import sys
import time
from dataclasses import dataclass

# TODO:
# check for rogue (empty) folders
# combine rogue input + output

parser = argparse.ArgumentParser(
	description='converts a music library to lower quality mp3',
	epilog='can be used to only scale cover images by specifying quality \'copy\'')


def check_directory_exists(dir):
	if not os.path.isdir(dir):
		parser.error(f'directory {dir} does not exist!')
	else:
		return os.path.abspath(dir)


parser.add_argument('inputpath', metavar='IN',
                    type=check_directory_exists, help='input path, must exist')
parser.add_argument('outputpath', metavar='OUT',
                    type=os.path.abspath, help='output path, will be created if it doesn\'t exist')
parser.add_argument('mp3_quality', metavar='Q', type=str,
                    help='quality argument for libmp3lame (0-9 or copy). copy does not work with input files other than *.mp3', choices=list(map(str, range(0, 10))) + ['copy'])
parser.add_argument('-c', '--clean', action='store_true',
                    help='remove rogue files in input and output')
parser.add_argument('--cover-scale', metavar='SIZE',
                    type=int, help='rescale covers to SIZExSIZE, a size of 0 discards the cover, omitting this argument copies the cover')
parser.add_argument('--limit', metavar='COUNT', type=int,
                    help='only convert the first COUNT files')
parser.add_argument('-j', '--threads', metavar='THREADS', type=int,
                    help='number of ffmpeg subprocesses to use, use all cores by default')
parser.add_argument('-y', '--yes', action='store_true',
                    help='skip action selection menu')

args = parser.parse_args()

inputpath = args.inputpath
outputpath = args.outputpath

print('input path: ', inputpath)
print('output path:', outputpath)


@dataclass
class InputFile:
	input: str
	output: str
	inputmtime: float
	outputmtime: float  # None if file doesn't exist


files = []
rogue_files_input = []
rogue_files_output = []

extensions = ['.mp3', '.m4a', '.wav', '.aac', '.flac', '.wma']


def listfiles(path):
	""" get a list of all files in path, recursively"""
	for directory_name, _, file_names in os.walk(path):
		for file_name in file_names:
			yield os.path.relpath(directory_name, path), file_name


print('scanning output directory', end='')
sys.stdout.flush()  # doesn't flush automatically without line ending
rogue_files_output = [os.path.normpath(os.path.join(outputpath, d, f))
                      for d, f in listfiles(outputpath)]
print(f', found {len(rogue_files_output)} files')

print('scanning input directory')

for directory_relative, filename in listfiles(inputpath):
	filename_base, extension = os.path.splitext(filename)

	file_path_input = os.path.normpath(
		os.path.join(inputpath, directory_relative, filename))

	if extension in extensions:
		file_path_output = os.path.normpath(os.path.join(
			outputpath, directory_relative, filename_base + '.mp3'))

		input_mtime = os.path.getmtime(file_path_input)
		output_mtime = os.path.getmtime(
			file_path_output) if os.path.isfile(file_path_output) else None

		files.append(InputFile(file_path_input, file_path_output,
                         input_mtime, output_mtime))

		if file_path_output in rogue_files_output:
			rogue_files_output.remove(file_path_output)
	else:
		rogue_files_input.append(file_path_input)

print(f'found {len(files)} music files')


def delete_checkdir(path):
	"""delete file or directory, also delete parent directories if they are empty"""
	while True:
		if os.path.isfile(path):
			os.remove(path)
		else:
			os.rmdir(path)
		path = os.path.dirname(path)
		if os.listdir(path):
			break


def delete_rogues():
	global rogue_files_input, rogue_files_output
	for rogue_file in (rogue_files_input + rogue_files_output):
		print(f' > {rogue_file}')
		delete_checkdir(rogue_file)
	rogue_files_input = []
	rogue_files_output = []


for name, rogue_files in [('input', rogue_files_input), ('output', rogue_files_output)]:
	if rogue_files:
		print(f'found {len(rogue_files)} rogue files in the {name} directory{", removing rogue files" if args.clean else ""}:')
		if args.clean:
			delete_rogues()


files = [file for file in files if file.inputmtime != file.outputmtime]
print(f'{len(files)} files need to be converted')

if args.limit is not None:
	print(f'limiting to {args.limit} files')
	files = files[:args.limit]


def get_command(file):
	""" create ffmpeg command to convert the file """
	command = [
		'ffmpeg',
		'-i', file.input,
		'-map', '0',
		'-y',
		'-hide_banner'
	]

	if args.mp3_quality == 'copy':
		command += ['-c:a', 'copy']
	else:
		command += [
			'-c:a', 'libmp3lame',
			'-q:a', args.mp3_quality
		]

	if args.cover_scale is None:
		command += ['-c:v', 'copy']
	else:
		if args.cover_scale == 0:
			command += ['-vn']
		else:
			command += [
				'-c:v', 'mjpeg',
				'-vf', f'scale={args.cover_scale}:{args.cover_scale}'
			]

	command += [file.output]
	return command


# action selection menu
if not args.yes:
	while True:
		print("""select action:
		[list] files to be converted
		[list cmd] (show ffmpeg commands)
		[list rogue] files
		[delete rogue] files
		[y]/[convert]
		[n]/[q]uit""")
		action = input('action: ').strip()

		if action in ['y', 'convert']:
			break
		elif action in ['n', 'q']:
			exit(0)
		elif action == 'list':
			for file in files:
				print(file.input)
				if file.outputmtime is None:
					print('does not exist in the output directory')
				else:
					print(f'in: {file.inputmtime} out: {file.outputmtime}')
		elif action == 'list cmd':
			for file in files:
				print(' '.join(get_command(file)))
		elif action == 'list rogue':
			for rogue_file in (rogue_files_input + rogue_files_output):
				print(f' > {rogue_file}')
		elif action == 'delete rogue':
			delete_rogues()
		else:
			print('unsupported action')


def convert(file):
	""" prepare and start conversion with ffmpeg process, returns handle to ffmpeg process """
	command = get_command(file)

	if path.exists(file.output):
		os.remove(file.output)
	if not path.isdir(path.dirname(file.output)):
		os.makedirs(path.dirname(file.output))

	return subprocess.Popen(command, stdin=subprocess.DEVNULL, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


@dataclass
class Worker:
	file: InputFile
	process: subprocess.Popen


@dataclass
class Error:
	file: InputFile
	retcode: int


workers = []
errors = []

try:
	cpu_count = args.threads or multiprocessing.cpu_count()
	total = len(files)
	done = 0
	time_start = time.time()

	while files or workers:
		# check running workers
		for i in range(len(workers) - 1, -1, -1):
			worker = workers[i]
			if worker.process.poll() is not None:
				if worker.process.returncode == 0:
					os.utime(worker.file.output,
					         (worker.file.inputmtime, worker.file.inputmtime))
					done += 1
				else:
					error = Error(worker.file, worker.process.returncode)
					errors.append(error)
					os.remove(worker.file.output)
				del workers[i]

		# restock workers
		while files and len(workers) < cpu_count:
			file = files.pop(0)
			worker = Worker(file, convert(file))
			workers.append(worker)

		elapsed = int(time.time() - time_start)
		print(f'{len(workers)} workers, {done}/{total} files converted in {str(datetime.timedelta(seconds=elapsed))}, {len(errors)} errors', end='\r')
		time.sleep(0.01)

except KeyboardInterrupt:
	print()
	print('KeyboardInterrupt. stopping workers and cleaning up partial files')
	for worker in workers:
		worker.process.kill()
		os.remove(worker.file.output)

print('\ndone')
if errors:
	print('errors:')
	print('RET\tFILE')
	for error in errors:
		print(f'{error.retcode}\t{error.file.input}')
